/*!
 * Bricky Photos Gallery
 * Bricky is a Google+ Photos inspired web gallery.
 *
 * Licensed under the MIT license.
 * (c) 2012-2014 Louis-Xavier Vignal
 */

/*global
    define
*/

/**
 * This layout is an implementation of the algorithm described in
 * "algorithm for a perfectly balanced photo gallery" by @jtreitz.
 *
 * @see {@link http://www.crispymtn.com/stories/the-algorithm-for-a-perfectly-balanced-photo-gallery}
 * @see {@link https://news.ycombinator.com/item?id=6198400}
 * @see {@link https://gist.github.com/mbijon/6227125}
 * @see {@link http://www.chromatic.io/FFgcm2d}
 *
 * @module   bricky/Layout/LinearLayout
 * @requires jquery
 * @requires bricky/Bricky
 * @requires bricky/Layout/AbstractLayout
 */
define('bricky/Layout/LinearLayout', [
    'jquery',
    'bricky/Bricky',
    'bricky/Layout/AbstractLayout'
], function ($, Bricky, AbstractLayout) {
    'use strict';

    // Generated by CoffeeScript 1.6.3
    var linear_partition, min;

    min = function(arr) {
      var computed, result, x, _i, _len;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        x = arr[_i];
        computed = x[0];
        if (!result || computed < result.computed) {
          result = {
            value: x,
            computed: computed
          };
        }
      }
      return result.value;
    };

    linear_partition = function(seq, k) {
      var ans, i, j, m, n, solution, table, x, y, _i, _j, _k, _l;
      n = seq.length;
      if (k <= 0) {
        return [];
      }
      if (k > n) {
        return seq.map(function(x) {
          return [x];
        });
      }
      table = (function() {
        var _i, _results;
        _results = [];
        for (y = _i = 0; 0 <= n ? _i < n : _i > n; y = 0 <= n ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (x = _j = 0; 0 <= k ? _j < k : _j > k; x = 0 <= k ? ++_j : --_j) {
              _results1.push(0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      solution = (function() {
        var _i, _ref, _results;
        _results = [];
        for (y = _i = 0, _ref = n - 1; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (x = _j = 0, _ref1 = k - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(0);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        table[i][0] = seq[i] + (i ? table[i - 1][0] : 0);
      }
      for (j = _j = 0; 0 <= k ? _j < k : _j > k; j = 0 <= k ? ++_j : --_j) {
        table[0][j] = seq[0];
      }
      for (i = _k = 1; 1 <= n ? _k < n : _k > n; i = 1 <= n ? ++_k : --_k) {
        for (j = _l = 1; 1 <= k ? _l < k : _l > k; j = 1 <= k ? ++_l : --_l) {
          m = min((function() {
            var _m, _results;
            _results = [];
            for (x = _m = 0; 0 <= i ? _m < i : _m > i; x = 0 <= i ? ++_m : --_m) {
              _results.push([Math.max(table[x][j - 1], table[i][0] - table[x][0]), x]);
            }
            return _results;
          })());
          table[i][j] = m[0];
          solution[i - 1][j - 1] = m[1];
        }
      }
      n = n - 1;
      k = k - 2;
      ans = [];
      while (k >= 0) {
        ans = [
          (function() {
            var _m, _ref, _ref1, _results;
            _results = [];
            for (i = _m = _ref = solution[n - 1][k] + 1, _ref1 = n + 1; _ref <= _ref1 ? _m < _ref1 : _m > _ref1; i = _ref <= _ref1 ? ++_m : --_m) {
              _results.push(seq[i]);
            }
            return _results;
          })()
        ].concat(ans);
        n = solution[n - 1][k];
        k = k - 1;
      }
      return [
        (function() {
          var _m, _ref, _results;
          _results = [];
          for (i = _m = 0, _ref = n + 1; 0 <= _ref ? _m < _ref : _m > _ref; i = 0 <= _ref ? ++_m : --_m) {
            _results.push(seq[i]);
          }
          return _results;
        })()
      ].concat(ans);
    };

    function part(seq, k) {
      if (k <= 0) {
        return [];
      }
      while (k) {
        try {
          return linear_partition(seq, k--);
        } catch (_error) {}
      }
    };

    var LinearLayout = function (element, options) {
        AbstractLayout.call(this, element, options);
    }

    LinearLayout.prototype = Object.create(AbstractLayout.prototype, {
        constructor: {
            value: LinearLayout,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    LinearLayout.prototype.render = function (images) {
        if (!$.isArray(images)) {
            return;
        }
        this.items = images;

        var viewportWidth, idealHeight, summedWidth, rows, weights, partition, index;

        // To find the number of rows (k) needed, we first scale the photos to half the window's height,
        // sum up their widths, then divide by the window's width.

        viewportWidth = $(this.element).width();
        idealHeight = parseInt($(window).height() / 2);

        summedWidth = this.items.reduce(function (sum, p) {
            return sum += (p.aspectRatio * idealHeight);
        }, 0);

        rows = Math.round(summedWidth / viewportWidth);

        if (rows < 1) {
            // (2a) Fallback to just standard size
            this.items.forEach(function (item) {
                item.thumbWidth = parseInt(idealHeight * item.aspectRatio) - this.itemMargin;
                item.thumbHeight = idealHeight;
                this._renderItem(item);
            }, this);

        } else {
            // (2b) Distribute photos over rows using the aspect ratio as weight
            weights = this.items.map(function (item) {
                return parseInt(item.aspectRatio * 100);
            });

            partition = part(weights, rows);

            // (3) Iterate through partition
            index = 0;
            partition.forEach(function (row) {
                var summedRatios, rowBuffer = [];

                row.forEach(function () {
                    rowBuffer.push(this.items[index++]);
                }, this);

                summedRatios = rowBuffer.reduce(function (sum, p) {
                    return sum += p.aspectRatio;
                }, 0);

                rowBuffer.forEach(function (item) {
                    item.thumbWidth = parseInt(viewportWidth / summedRatios * item.aspectRatio) - this.itemMargin;
                    item.thumbHeight = parseInt(viewportWidth / summedRatios);
                    this._renderItem(item);
                }, this);
            }, this);
        }
    };

    Bricky.Layout.LinearLayout = LinearLayout;

    return LinearLayout;
});